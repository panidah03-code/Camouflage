<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camouflage Shader Demo</title>
  <style>
    html,body { height:100%; margin:0; background:#222; color:#eee; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #ui { position:fixed; left:12px; top:12px; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; backdrop-filter: blur(4px); }
    label{display:block;font-size:13px;margin:6px 0 2px}
    canvas { width:100vw; height:100vh; display:block }
    select,input[type=range]{ width:220px }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <div id="ui">
    <label>Mode</label>
    <select id="mode"><option value="0">Woodland</option><option value="1">Desert</option><option value="2">Snow</option></select>
    <label>Scale</label>
    <input id="scale" type="range" min="0.2" max="6" step="0.01" value="1.6">
    <label>Contrast</label>
    <input id="contrast" type="range" min="0" max="2" step="0.01" value="1.0">
    <label>Seed</label>
    <input id="seed" type="range" min="0" max="1000" step="1" value="1">
    <div style="margin-top:8px; font-size:12px; opacity:0.9">Tip: change Mode & Scale for different pattern sizes.</div>
  </div>

  <script id="vs" type="x-shader/x-vertex">#version 100
  attribute vec2 a_pos;
  varying vec2 v_uv;
  void main(){ v_uv = a_pos * 0.5 + 0.5; gl_Position = vec4(a_pos,0.0,1.0); }
  </script>

  <script id="fs" type="x-shader/x-fragment">#version 100
  precision mediump float;
  varying vec2 v_uv;
  uniform vec2 u_res;
  uniform float u_time;
  uniform float u_scale;
  uniform float u_contrast;
  uniform float u_seed;
  uniform int u_mode; // 0 woodland,1 desert,2 snow

  // Hash / noise helpers
  float hash(vec2 p){ p = fract(p * vec2(123.34, 456.21) + u_seed); p += dot(p, p + 45.32); return fract(p.x * p.y);
  }

  float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    // four corners
    float a = hash(i + vec2(0.0,0.0));
    float b = hash(i + vec2(1.0,0.0));
    float c = hash(i + vec2(0.0,1.0));
    float d = hash(i + vec2(1.0,1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
  }

  // fbm - fractional brownian motion
  float fbm(vec2 p){ float v=0.0; float a=0.5; mat2 m=mat2(1.6,1.2,-1.2,1.6);
    for(int i=0;i<5;i++){ v += a * noise(p); p = m*p*1.9; a *= 0.5; }
    return v;
  }

  // cellular-like blobs using fbm + thresholding
  float blobs(vec2 p, float scale){
    p *= scale;
    float b1 = fbm(p * 0.6 + 0.3*u_time);
    float b2 = fbm(p * 1.4 - 0.7*u_time);
    float spots = fbm(p * 3.0 + vec2(5.2));
    float mixv = smoothstep(0.2, 0.8, mix(b1, b2, 0.5) * 0.8 + 0.2*spots);
    return mixv;
  }

  // palette lookup - three colors
  vec3 palette(int mode, float t){
    if(mode==0){ // woodland greens/browns
      vec3 c0 = vec3(0.08,0.18,0.05);
      vec3 c1 = vec3(0.22,0.28,0.07);
      vec3 c2 = vec3(0.36,0.22,0.08);
      return mix(mix(c0,c1, smoothstep(0.0,0.5,t)), c2, smoothstep(0.5,1.0,t));
    } else if(mode==1){ // desert tans
      vec3 c0 = vec3(0.82,0.74,0.57);
      vec3 c1 = vec3(0.66,0.55,0.38);
      vec3 c2 = vec3(0.48,0.39,0.25);
      return mix(mix(c0,c1, smoothstep(0.0,0.5,t)), c2, smoothstep(0.5,1.0,t));
    } else { // snow whites / blue-gray
      vec3 c0 = vec3(0.95,0.97,0.99);
      vec3 c1 = vec3(0.85,0.88,0.92);
      vec3 c2 = vec3(0.6,0.66,0.72);
      return mix(mix(c0,c1, smoothstep(0.0,0.5,t)), c2, smoothstep(0.5,1.0,t));
    }
  }

  void main(){
    vec2 uv = v_uv * u_res / min(u_res.x, u_res.y);
    vec2 p = uv - 0.5 * u_res / min(u_res.x, u_res.y);
    float scale = u_scale;

    // layer 1: large irregular blobs
    float large = blobs(p, scale * 0.6);

    // layer 2: medium spots
    float medium = blobs(p + 37.0, scale * 1.6);

    // layer 3: fine texture
    float fine = fbm(p * scale * 8.0 + 7.0);

    // combine with different thresholds to produce multi-tone pattern
    float t = mix(large, medium, 0.45);
    t = mix(t, fine * 0.7, 0.25);
    t = pow(t, 1.0 - 0.5 * u_contrast);

    // create 3 bands
    float band = smoothstep(0.15, 0.45, t) + smoothstep(0.45,0.75, t);
    // remap into [0,1] for palette
    float paletteIndex = clamp(t, 0.0, 1.0);

    vec3 color = palette(u_mode, paletteIndex);

    // add subtle shadows/highlights for depth
    float light = 0.25 * fbm(p * scale * 0.7 + u_time * 0.05);
    color *= 0.9 + 0.15*light;

    // final tone adjustment for snow (slightly bluish tint)
    if(u_mode==2){ color = mix(color, vec3(0.85,0.9,1.0), 0.07); }

    gl_FragColor = vec4(color,1.0);
  }
  </script>

  <script>
  // Minimal WebGL setup
  (function(){
    const canvas = document.getElementById('gl');
    const gl = canvas.getContext('webgl');
    if(!gl){ alert('WebGL not supported'); return; }

    function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }
    window.addEventListener('resize', resize); resize();

    function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); } return s; }

    const vsSrc = document.getElementById('vs').textContent;
    const fsSrc = document.getElementById('fs').textContent;
    const vs = compile(gl.VERTEX_SHADER, vsSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
    const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog); if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); }
    gl.useProgram(prog);

    const aPos = gl.getAttribLocation(prog, 'a_pos');
    const quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    const u_res = gl.getUniformLocation(prog, 'u_res');
    const u_time = gl.getUniformLocation(prog, 'u_time');
    const u_scale = gl.getUniformLocation(prog, 'u_scale');
    const u_contrast = gl.getUniformLocation(prog, 'u_contrast');
    const u_seed = gl.getUniformLocation(prog, 'u_seed');
    const u_mode = gl.getUniformLocation(prog, 'u_mode');

    const modeEl = document.getElementById('mode');
    const scaleEl = document.getElementById('scale');
    const contrastEl = document.getElementById('contrast');
    const seedEl = document.getElementById('seed');

    let start = performance.now();
    function frame(){
      gl.uniform2f(u_res, canvas.width, canvas.height);
      gl.uniform1f(u_time, (performance.now() - start) * 0.001);
      gl.uniform1f(u_scale, parseFloat(scaleEl.value));
      gl.uniform1f(u_contrast, parseFloat(contrastEl.value));
      gl.uniform1f(u_seed, parseFloat(seedEl.value));
      gl.uniform1i(u_mode, parseInt(modeEl.value));

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
